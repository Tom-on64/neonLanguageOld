import Neon from "./neon.js";

class Parser {
  /**
   * The Neon parser
   * @param {Array} Array of tokens generated by the lexer
   */
  constructor(tokens) {
    this.meta = tokens.shift();
    this.tokens = tokens;
    this.index = 0;
    this.currentToken = this.tokens[this.index];
  }

  nextBranch() {
    if (this.#match("keyword")) return this.parseKeyword();
    else if (this.#match("modifier")) return this.parseModifier();
    else if (this.#match("type")) return this.parseType();

    return this.#advance();
  }

  parseModifier() {
    const modifiers = [];

    while (!this.#match("type") && !this.#match("keyword")) {
      modifiers.push(this.#consume("modifier").value);
    }

    const data = this.nextBranch();

    data.modifiers = modifiers;

    return data;
  }

  parseKeyword() {
    switch (this.currentToken.value) {
      case "import":
        this.#advance();
        const imports = [this.#consume("identifier").value];
        this.#consume("EOL");
        return { type: "statement:import", imports };
      case "class":
        this.#advance();
        const identifier = this.#consume("identifier").value;

        let inherits = null;
        if (this.#match("keyword", "extends")) {
          this.#advance();
          inherits = this.#consume("identifier").value;
        }

        const body = this.parseClassBody();

        return {
          type: "statement:declaration",
          declares: "class",
          identifier,
          extends: inherits,
          body,
        };
      default:
        Neon.error(201, [this.currentToken.value]);
    }
  }

  parseType() {
    const type = this.#consume("type").value;
    const identifier = this.#consume("identifier").value;

    if (!this.#match("special")) {
      this.#consume("EOL");
      return {
        type: "statement:declaration",
        declares: "property",
        propType: type,
        identifier,
        value: null,
      };
    }

    if (this.#match("special", "=")) {
      this.#advance();
      const value = this.#consume(type);
      if (this.meta.types.includes(value.type))
        value.type = `literal:${value.type}`;
      this.#consume("EOL");
      return {
        type: "statement:declaration",
        declares: "property",
        propType: type,
        identifier,
        value,
      };
    } else if (this.#match("special", "(")) {
      const parameters = [];

      this.#consume("special", "(");

      while (!this.#match("special", ")")) {
        parameters.push(this.parseExpression());
        if (this.#match("special", ",")) this.#consume("special", ",");
      }

      this.#consume("special", ")");

      const body = this.parseMethodBody();

      return {
        type: "statement:declaration",
        declares: "method",
        returnType: type,
        identifier,
        parameters,
        body,
      };
    } else Neon.error(200, ["= or (", this.currentToken.value]);
  }

  parseClassBody() {
    this.#consume("special", "{");

    const body = [];

    while (!this.#match("special", "}")) body.push(this.nextBranch());

    this.#consume("special", "}");

    return body;
  }

  parseMethodBody() {
    const body = [];

    this.#consume("special", "{");

    while (!this.#match("special", "}")) {
      this.parseThingInMethod();
    }

    this.#consume("special", "}");

    return body;
  }

  parseThingInMethod() {

  }

  parseStatement() {
    return this.#advance();
  }

  parseExpression() {
    return this.#advance();
  }

  parse() {
    const ast = [];

    while (this.currentToken.type !== "EOF") ast.push(this.nextBranch());

    return ast;
  }

  // Helper
  #advance(amount = 1) {
    const lastToken = this.currentToken;
    this.index += amount;
    this.currentToken = this.tokens[this.index];
    return lastToken;
  }

  #peek(amount = 1) {
    return this.tokens[this.index + amount];
  }

  #match(type, value) {
    if (
      this.currentToken.type === type &&
      (value === undefined || this.currentToken.value === value)
    )
      return true;
    else return false;
  }

  #expect(type, value) {
    if (this.#match(type, value)) return true;
    else Neon.error(200, [type, this.currentToken.type]);
  }

  #consume(type, value) {
    if (this.#expect(type, value)) return this.#advance();
  }
}

export default Parser;
