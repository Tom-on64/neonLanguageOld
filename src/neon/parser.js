// For errors
import Neon from "./neon.js";

class Parser {
  /**
   * The Neon parser
   * @param {Array} Array of tokens generated by the lexer
   */
  constructor(tokens) {
    this.meta = tokens.shift();
    this.meta.statements = ["if", "for", "while", "try"];
    this.tokens = tokens;
    this.index = 0;
    this.currentToken = this.tokens[this.index];
  }

  nextBranch() {
    if (this.#match("keyword")) return this.parseKeyword();
    else if (this.#match("modifier")) return this.parseModifier();
    else if (this.#match("type")) return this.parseType();

    return this.#advance();
  }

  parseModifier() {
    const modifiers = [];

    while (!this.#match("type") && !this.#match("keyword")) {
      modifiers.push(this.#consume("modifier").value);
    }

    const data = this.nextBranch();

    data.modifiers = modifiers;

    return data;
  }

  parseKeyword() {
    switch (this.currentToken.value) {
      case "import":
        this.#advance();
        const imports = [this.#consume("identifier").value];
        this.#consume("EOL");
        return { type: "statement:import", imports };
      case "class":
        this.#advance();
        const identifier = this.#consume("identifier").value;

        let inherits = null;
        if (this.#match("keyword", "extends")) {
          this.#advance();
          inherits = this.#consume("identifier").value;
        }

        const body = this.parseClassBody();

        return {
          type: "statement:declaration",
          declares: "class",
          identifier,
          extends: inherits,
          body,
        };
      default:
        Neon.error(201, [this.currentToken.value]);
    }
  }

  parseType() {
    const type = this.#consume("type").value;
    const identifier = this.#consume("identifier").value;

    if (!this.#match("special")) {
      this.#consume("EOL");
      return {
        type: "statement:declaration",
        declares: "property",
        propType: type,
        identifier,
        value: null,
      };
    }

    if (this.#match("special", "=")) {
      this.#advance();
      const value = this.#consume(type);
      if (this.meta.types.includes(value.type))
        value.type = `literal:${value.type}`;
      this.#consume("EOL");
      return {
        type: "statement:declaration",
        declares: "property",
        propType: type,
        identifier,
        value,
      };
    } else if (this.#match("special", "(")) {
      const parameters = [];

      this.#consume("special", "(");

      while (!this.#match("special", ")")) {
        parameters.push(this.parseExpression());
        if (this.#match("special", ",")) this.#consume("special", ",");
      }

      this.#consume("special", ")");

      const body = this.parseMethodBody();

      return {
        type: "statement:declaration",
        declares: "method",
        returnType: type,
        identifier,
        parameters,
        body,
      };
    } else Neon.error(200, ["= or (", this.currentToken.value]);
  }

  parseClassBody() {
    this.#consume("special", "{");

    const body = [];

    while (!this.#match("special", "}")) body.push(this.nextBranch());

    this.#consume("special", "}");

    return body;
  }

  parseMethodBody() {
    const body = [];

    this.#consume("special", "{");
    while (!this.#match("special", "}")) body.push(this.parseThingInMethod());
    this.#consume("special", "}");

    return body;
  }

  parseThingInMethod() {
    const tokens = this.#lookAhead(this.tokens.length - 1, "EOL");

    if (this.isStatement(tokens)) return this.parseStatement();
    else return this.parseExpression();
  }

  parseStatement() {
    const statement = { type: "statement:error" };

    // TODO: Parse conditions/loops
    statement.type = "statement:assign";
    statement.assigns = this.#consume("identifier").value;

    this.#consume("special", "=");

    const value = this.#advance();
    if (this.meta.types.includes(value.type))
      statement.to = { type: "literal:" + value.type, value: value.value };

    this.#consume("EOL");

    return statement;
  }

  parseExpression() {
    const callee = this.#consume("identifier");
    this.#consume("special", ".");
    const prop = this.#consume("identifier");
    this.#consume("special", "(");
    const args = [];

    while (!this.#match("special", ")")) {
      if (this.#peek(1).type === "operator") {
        const a = this.#consume("identifier");
        const mode = this.parseOperation(this.#consume("operator"));
        const b = this.#consume("identifier");

        args.push({ type: "expression:operation", mode, a, b });
        if (this.#match("special", ",")) this.#consume("special", ",");

        continue;
      }

      if (this.#match("identifier"))
        args.push({ type: `variable`, value: this.#advance().value });
      else if (this.meta.types.includes(this.currentToken.type))
        args.push({ type: `literal:${this.#advance().value}` });
      else args.push(this.parseExpression());

      if (this.#match("special", ",")) this.#consume("special", ",");
    }

    this.#consume("special", ")");
    this.#consume("EOL");

    return { type: "expression:call", callee, prop, args };
  }

  parseOperation(operator) {
    // += -= /= *=
    if (operator === "!") return "not";
    else if (operator === "+") return "add";
    else if (operator === "++") return "inc";
    else if (operator === "-") return "sub";
    else if (operator === "--") return "dec";
    else if (operator === "*") return "mul";
    else if (operator === "/") return "div";
    else if (operator === "**") return "pow";
    else if (operator === "%") return "mod";
    else if (operator === "&") return "band";
    else if (operator === "|") return "bor";
    else if (operator === "^") return "bxor";
    else if (operator === "~") return "bnot";
    else if (operator === "<<") return "bshiftleft";
    else if (operator === ">>") return "bshiftright";
    else if (operator === "==") return "equal";
    else if (operator === ">") return "more";
    else if (operator === ">=") return "moreoreq";
    else if (operator === "<") return "less";
    else if (operator === "<=") return "lessoreq";
    else if (operator === "&&") return "and";
    else if (operator === "||") return "or";
    else return "unknown";
  }

  isStatement(tokens) {
    let isStatement = false;
    tokens.forEach((t) => {
      if (t.type === "identifier") return;
      else if (t.type === "keyword") {
        if (this.meta.statements.includes(t.value)) isStatement = true;
        return;
      } else if (t.type === "type") isStatement = true;
      else if (t.type === "special" && t.value === "=") isStatement = true;
    });

    return isStatement;
  }

  /**
   * Generates an AST (Abstract Syntaxt Tree) from tokens.
   * @returns {Array} Abstract Syntax Tree
   */
  parse(logAst) {
    const ast = [];

    while (this.currentToken.type !== "EOF") ast.push(this.nextBranch());
    if (logAst) console.log(ast);

    return ast;
  }

  // Helper
  /**
   * Advances by an amount of tokens
   * @param {number} amount Amount of tokens to advance by
   * @returns Last token
   */
  #advance(amount = 1) {
    const lastToken = this.currentToken;
    this.index += amount;
    this.currentToken = this.tokens[this.index];
    return lastToken;
  }

  /**
   * Peek forward by an amount o tokens
   * @param {number} amount Amount of tokens to peek forward by
   * @returns {object} Found token
   */
  #peek(amount = 1) {
    return this.tokens[this.index + amount];
  }

  /**
   * If type and value are correct, returns True, otherwise returns False.
   * @param {string} type Type to match
   * @param {string?} value Value to match (if undefined, doesn't check)
   * @returns {bool} If type and value are correct
   */
  #match(type, value) {
    if (
      this.currentToken.type === type &&
      (value === undefined || this.currentToken.value === value)
    )
      return true;
    else return false;
  }

  /**
   * If type and value are correct, returns True, otherwise throws an error.
   * @param {string} type Type to expect
   * @param {string?} value Value to expect (if undefined, doesn't check)
   * @returns {bool} If type and value are correct
   */
  #expect(type, value) {
    if (this.#match(type, value)) return true;
    else Neon.error(200, [type, this.currentToken.type]);
  }

  /**
   * If type and value are correct, returns True and advances, otherwise throws an error.
   * @param {string} type Type to consume
   * @param {string?} value Value to consume (if undefined, doesn't check)
   * @returns {bool} If type and value are correct
   */
  #consume(type, value) {
    if (this.#expect(type, value)) return this.#advance();
  }

  /**
   * Returns tokens
   * @param {number} amount Amount of tokens to look return
   * @param {string?} untilType If this type is reached, will stop
   * @returns {Array} Array of tokens
   */
  #lookAhead(amount, untilType = "EOF") {
    const tokens = [];

    for (let i = 1; i < amount; i++) {
      const token = this.#peek(i);
      if (!token || token.type === untilType) break;
      tokens.push(token);
    }

    return tokens;
  }
}

export default Parser;
